[{"C:\\min\\movie_app_react\\src\\App.js":"1","C:\\min\\movie_app_react\\src\\index.js":"2","C:\\min\\movie_app_react\\src\\FunctionEx.js":"3","C:\\min\\movie_app_react\\src\\ClassEx.js":"4","C:\\min\\movie_app_react\\src\\Movie.js":"5"},{"size":1681,"mtime":1606828541666,"results":"6","hashOfConfig":"7"},{"size":395,"mtime":1606223339010,"results":"8","hashOfConfig":"7"},{"size":1506,"mtime":1606398557393,"results":"9","hashOfConfig":"7"},{"size":2858,"mtime":1606401337093,"results":"10","hashOfConfig":"7"},{"size":945,"mtime":1606828996764,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"jdg3kr",{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\min\\movie_app_react\\src\\App.js",[],"C:\\min\\movie_app_react\\src\\index.js",[],"C:\\min\\movie_app_react\\src\\FunctionEx.js",[],"C:\\min\\movie_app_react\\src\\ClassEx.js",["23"],"import React from 'react';\r\nimport Proptypes from 'prop-types';\r\n\r\n/* \r\n  # 클래스형 컴포넌트\r\n    # React.Component를 상속 받아서 사용함. 그 안에 render()라는 메소드 존재. \r\n\r\n  --\r\n  Life Cycle\r\n  # Mounting\r\n    # 먼저 호출되는 function <-> vue: created(?)\r\n    # constructor() -- 자바스크립트에서 실행되는 메서드\r\n    # render()\r\n    # componentDidMount()\r\n  # Updating\r\n    # render()\r\n    # componentDidUpdate()\r\n  # Unmounting\r\n    페이지를 바꿀 때, state를 사용해서 컴포넌트를 교체 할 때, 컴포넌트가 바뀔 때 호출.\r\n    # componentWillUnmount()\r\n  --\r\n*/\r\n\r\nclass ClassEx extends React.Component {\r\n  /* \r\n    리액트가 자동으로 render 메소드를 실행함. 자바 main()이랑 같은 듯.\r\n    클래스 컴포넌트를 이야기 하는 이유 ? 'state' 때문 ** state는 object임. \r\n    state vuex에서 나오는 개념이랑 비슷한듯. \r\n   */\r\n  state = {\r\n    count: 0\r\n  };\r\n  \r\n  /* \r\n    버튼을 누르면 실행되는 코드. 이건 리액트가 아니라 자바스크립트임. \r\n\r\n    # Do not mutate state directly. Use setState()\r\n      add 메소드에서 this.state.count = -1; 이런식으로 state를 직접적으로 변경하려 했을 때 나오는 오류.\r\n      vuex에서 getters로 계산하지 않는 것과 같음. 좀 더 엄격한듯?  \r\n      리액트는 render 함수를 이런 경우 실행하지 않음 -> 매번 state의 상태를 변경 할 때는 리액트가 render() 함수를 한 번 더 호출 하는 것과 같음. \r\n        this.state.count = -1 ---> setState()를 통해서 state를 refresh하고 render함수를 다시 호출할 것임.. state는 object임. \r\n      --> 이런 점+DOM을 통해서 새로고침을 하지 않고 내용 변경 가능\r\n\r\n    하지만 이런 방식은 좋지는 않음. state에 의존하지 않기 위해서 --> 나중에 나은 방법 나옴. \r\n  */\r\n  add = () => {\r\n    // this.state.count = -1;\r\n    // this.setState({ count : this.state.count + 1 });\r\n\r\n    // current를 통해서 state에 접근 하는 것이 좋음. current = 현재 값. \r\n    this.setState(current => ({ count: current.count + 1 }));\r\n  };\r\n\r\n  minus = () => {\r\n    // console.log(\"minus\");\r\n    this.setState(current => ({ count: current.count - 1}));\r\n  }\r\n\r\n  /* \r\n    Q. 차이점?\r\n    this.add <-> this.add() \r\n      # this.add  : 클릭 했을 때 \r\n      # this.add() : 즉시 ====> 이렇게 하면 클릭했을 때 메소드 호출이 되지 않고 그냥 랜더링 되면서 호출됨\r\n  */\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1>Function Component Example</h1>\r\n        <h2>The number is {this.state.count}</h2>\r\n        <button onClick={this.add}>Add</button> \r\n        <button onClick={this.minus}>Minus</button>\r\n      </div>      \r\n    )\r\n  }\r\n}\r\n\r\nexport default ClassEx;","C:\\min\\movie_app_react\\src\\Movie.js",[],{"ruleId":"24","severity":1,"message":"25","line":2,"column":8,"nodeType":"26","messageId":"27","endLine":2,"endColumn":17},"no-unused-vars","'Proptypes' is defined but never used.","Identifier","unusedVar"]